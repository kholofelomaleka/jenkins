REVISITING DOCKER & JENKINS

This repo is meant to help me understand:
-> Writing my own Dockerfiles
-> Minimising image dependencies on public images (building own images)
-> Creating and using Data Volumes, including backups (Check linux notes)
-> Creating containerized "Build environments" using containers
-> Handling "secret" data with images and Jenkins


DOCKER CHANGES

Docker Volumes
- Persist until manual deletion from docker host.
- Integrate with storage plugins to enable shared data volumes across a cluster.

Docker Networks
- Docker Host uses vm's ip address, networks can be independently created, named and maintained
  without any containers or images.
- Containers can be attached to a network and even the simplest form of ocker offers service discovery
  and exposes all containers inside the network via DNS.

Docker Compose
- Makes is simple to create multiple networks, volumes and services.

---> add rest of changes later!


JENKINS CHANGES

Jenkins version
- Cloudbees Dockerfiles

Docker Plugins

---> more changes later!


PART 1 - Thinking Inside the Container

PART 2 - Puting Jenkins in a Docker Container

 LESSON 1 - Setup and Run First Jenkins Image

 - Deploying Jenkins with these architectural components in mind:
	-> Jenkins master server (Java process)
	-> Jenkins master data (Plugins, Job definitions, etc...)
	-> NGINX web proxy (ssl certs for security etc...)
	-> Build slave agents (Containers that can be ssh'd into, or JNLP connection to, Jenkins Master)

 - DAEMONIZING 
 	-> Running jenkins using the -d flag -- prevents logs from showing on the terminal
		$ docker run -p 8080:8080 --name=jenkins-master -d jenkins/jenkins
	-> Memory settings, using the --env JAVA_OPTS="" flag to limit Jenkins memory usage.
		$ docker run -p 8080:8080 --name=jenkins-master -d --env JAVA_OPTS="-Xmx8192m" jenkins/jenkins
	-> Increasing The Connection Pool using --env JENKINS_OPTS=" --handlerCountMax=300" - To set limit of connections
		$ docker run -p 8080:8080 --name=jenkins-master -d --env JAVA_OPTS="-Xmx8192m" --env JENKINS_OPTS=" --handlerCountMax=300" jenkins/jenkins
 - COMMENTS
   -- The Jenkins container/image is useful but:
	-> Has no consistent logging,
	-> No persistence,
	-> No web server proxy in front of it.
	-> Keep in mind Jenkins versions...
	-> dockerjenkins_tutorial/tutorial01/makefile
 
 LESSON 2 - A JENKINS BASE IMAGE WRAPPER
 
 - Work within a Dockerfile
	-> Set env vars
	-> Create folders and permissions
	-> dockerjenkins_tutorial/tutorial01/Dockerfile
 - Testing the Dockerfile
	-> $ docker build -t myjenkins . -- Builds Jenkins using the Dockerfile
	-> $ docker stop jenkins-master -- If jenkins-master is still running, stop it.
	-> $ docker rm jenkins-master -- Remove the container using this command.
	-> $ docker run -p 8080:8080 --name=jenkins-master -d myjenkins
 - Run Basic Commands Against The Container
	-> docker exec jenkins-master ps -ef |grep java -- This will check if the Jenkins Java process is running.
 - Setup a Log Folder
	-> Add "RUN mkdir /var/log/jenkins" to the Dockerfile to persist the Jenkins log file
	- Copy and view log:
	-> $ docker cp jenkins-master:/var/log/jenkins/jenkins.log jenkins.log; cat jenkins.log;
 - COMMENTS
   -- Seems below params are depricated?
	ENV JAVA_OPTS="-Xmx8192m"
	ENV JENKINS_OPTS=" --handlerCountMax=300"
